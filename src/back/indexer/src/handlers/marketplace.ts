import { BN, IdlAccounts, EventParser, Program } from "@coral-xyz/anchor";
import { KeyedAccountInfo, Logs, PublicKey, Connection } from "@solana/web3.js";
import { DataMarketplace } from "../../../programs/target/types/data_marketplace";
import { prisma } from "../lib/prisma";
import { MerkleService } from "../services/merkleService";
import { ScheduleService } from "../services/scheduleService";
import bs58 from "bs58";

// Anchor event discriminators
const LISTING_CREATED_DISCRIMINATOR = "ListingCreated";
const LISTING_UPDATED_DISCRIMINATOR = "ListingUpdated";
const LISTING_REMOVED_DISCRIMINATOR = "ListingRemoved";
const DATA_PASS_PURCHASED_DISCRIMINATOR = "DataPassPurchased";
const REVENUE_CLAIMED_DISCRIMINATOR = "RevenueClaimed";

export function createHandlers(
  program: Program<DataMarketplace>, 
  connection: Connection,
  merkleService: MerkleService
) {
  return {
    async handleLogs(logs: Logs) {
      try {
        // Parse Anchor events from logs
        const eventParser = new EventParser(program.programId, program.coder);
        const events = eventParser.parseLogs(logs.logs);
        
        for (const event of events) {
          await processEvent(event, merkleService);
        }
      } catch (error) {
        console.error(`Error processing logs for ${logs.signature}:`, error);
      }
    },

    async handleAccountChange(account: KeyedAccountInfo) {
      try {
        // Determine account type and decode
        const accountType = determineAccountType(account.accountInfo.data);
        
        switch (accountType) {
          case 'marketplaceConfig':
            const config = program.account.marketplaceConfig.coder.accounts.decode('marketplaceConfig', account.accountInfo.data);
            await indexMarketplaceConfigAccount(config, account.accountId);
            break;
          case 'dataListing':
            const listing = program.account.dataListing.coder.accounts.decode('dataListing', account.accountInfo.data);
            await indexDataListingAccount(listing, account.accountId);
            break;
          case 'dataPass':
            const pass = program.account.dataPass.coder.accounts.decode('dataPass', account.accountInfo.data);
            await indexDataPassAccount(pass, account.accountId);
            break;
          case 'dataSeller':
            const seller = program.account.dataSeller.coder.accounts.decode('dataSeller', account.accountInfo.data);
            await indexDataSellerAccount(seller, account.accountId);
            break;
          case 'merkleDistributor':
            const distributor = program.account.merkleDistributor.coder.accounts.decode('merkleDistributor', account.accountInfo.data);
            await indexMerkleDistributorAccount(distributor, account.accountId);
            break;
        }
      } catch (error) {
        console.error('Error decoding account:', error);
      }
    },

    processEvent: (event: any) => processEvent(event, merkleService)
  };
}

// Account discriminators (these are generated by Anchor based on account name)
const ACCOUNT_DISCRIMINATORS = {
  marketplaceConfig: Buffer.from([246, 28, 6, 87, 251, 45, 50, 42]), // sha256("account:MarketplaceConfig")[0:8]
  dataListing: Buffer.from([219, 173, 88, 157, 167, 126, 148, 53]), // sha256("account:DataListing")[0:8]
  dataSeller: Buffer.from([175, 65, 139, 87, 51, 188, 150, 175]), // sha256("account:DataSeller")[0:8]
  dataPass: Buffer.from([62, 128, 246, 117, 108, 238, 9, 58]), // sha256("account:DataPass")[0:8]
  merkleDistributor: Buffer.from([77, 119, 139, 144, 62, 113, 204, 199]), // sha256("account:MerkleDistributor")[0:8]
};

// Helper function to determine account type based on discriminator
function determineAccountType(data: Buffer): string | null {
  if (data.length < 8) return null;
  
  const discriminator = data.slice(0, 8);
  
  // Compare with known discriminators
  for (const [accountType, knownDiscriminator] of Object.entries(ACCOUNT_DISCRIMINATORS)) {
    if (discriminator.equals(knownDiscriminator)) {
      return accountType;
    }
  }
  
  return null;
}

// Helper function to index data listing accounts
async function indexDataListingAccount(listing: IdlAccounts<DataMarketplace>["dataListing"], accountId: PublicKey) {
  try {
    const listingData = {
      listing_id: listing.listingId.toString(),
      seller_address: listing.seller.toString(),
      start_date: new Date(listing.startDate.toNumber() * 1000),
      end_date: new Date(listing.endDate.toNumber() * 1000),
      price_per_day: listing.pricePerDay.toString(),
      account_address: accountId.toString(),
      is_active: true,
    };

    // Upsert listing data
    await prisma.dataListing.upsert({
      where: { listing_id: listingData.listing_id },
      update: listingData,
      create: listingData,
    });

    console.log(`Indexed listing ${listing.listingId.toString()} for seller ${listing.seller.toString()}`);
  } catch (error) {
    console.error('Error storing listing:', error);
  }
}

// Helper function to index data pass accounts
async function indexDataPassAccount(pass: IdlAccounts<DataMarketplace>["dataPass"], accountId: PublicKey) {
  try {
    // Store pass metadata for access verification
    console.log(`Indexed data pass ${pass.passId.toString()} for buyer ${pass.buyer.toString()}`);
  } catch (error) {
    console.error('Error storing data pass:', error);
  }
}

// Helper function to index data seller accounts
async function indexDataSellerAccount(seller: IdlAccounts<DataMarketplace>["dataSeller"], accountId: PublicKey) {
  try {
    const sellerData = {
      seller_address: seller.seller.toString(),
      listing_id: seller.listingId ? seller.listingId.toString() : null,
      total_revenue: seller.totalRevenue.toString(),
      unclaimed_revenue: seller.unclaimedRevenue.toString(),
      account_address: accountId.toString(),
    };

    // Upsert seller data
    await prisma.dataSeller.upsert({
      where: { seller_address: sellerData.seller_address },
      update: sellerData,
      create: sellerData,
    });

    console.log(`Indexed seller account for ${seller.seller.toString()} with listing ${seller.listingId?.toString() || 'none'}`);
  } catch (error) {
    console.error('Error storing seller account:', error);
  }
}

// Helper function to index marketplace config account
async function indexMarketplaceConfigAccount(config: IdlAccounts<DataMarketplace>["marketplaceConfig"], accountId: PublicKey) {
  try {
    const configData = {
      authority: config.authority.toString(),
      current_period_revenue: config.currentPeriodRevenue.toString(),
      total_lifetime_revenue: config.totalLifetimeRevenue.toString(),
      listing_counter: config.listingCounter.toString(),
      pass_counter: config.passCounter.toString(),
      snapshot_period: config.snapshotPeriod.toString(),
      account_address: accountId.toString(),
    };

    // Upsert marketplace config (should only be one)
    await prisma.marketplaceConfig.upsert({
      where: { account_address: accountId.toString() },
      update: configData,
      create: configData,
    });

    console.log(`Indexed marketplace config: ${config.listingCounter.toString()} listings, ${config.passCounter.toString()} passes`);
  } catch (error) {
    console.error('Error storing marketplace config:', error);
  }
}

// Helper function to index merkle distributor accounts
async function indexMerkleDistributorAccount(distributor: IdlAccounts<DataMarketplace>["merkleDistributor"], accountId: PublicKey) {
  try {
    const distributorData = {
      period_id: distributor.periodId.toString(),
      merkle_root: bs58.encode(distributor.merkleRoot),
      total_pool_balance: distributor.totalPoolBalance.toString(),
      snapshot_timestamp: new Date(distributor.snapshotTimestamp.toNumber() * 1000),
      total_claims: distributor.totalClaims.toString(),
      claimed_amount: distributor.claimedAmount.toString(),
      account_address: accountId.toString(),
    };

    // Upsert merkle distributor data
    await prisma.merkleDistributor.upsert({
      where: { period_id: BigInt(distributor.periodId.toString()) },
      update: distributorData,
      create: {
        ...distributorData,
        period_id: BigInt(distributor.periodId.toString()),
      },
    });

    console.log(`Indexed merkle distributor for period ${distributor.periodId.toString()}`);
  } catch (error) {
    console.error('Error storing merkle distributor:', error);
  }
}

// Helper function to process Anchor events
async function processEvent(event: any, merkleService: MerkleService) {
  try {
    switch (event.name) {
      case LISTING_CREATED_DISCRIMINATOR:
        await handleListingCreated(event.data);
        break;
      case LISTING_UPDATED_DISCRIMINATOR:
        await handleListingUpdated(event.data);
        break;
      case LISTING_REMOVED_DISCRIMINATOR:
        await handleListingRemoved(event.data);
        break;
      case DATA_PASS_PURCHASED_DISCRIMINATOR:
        await handleDataPassPurchased(event.data, merkleService);
        break;
      case REVENUE_CLAIMED_DISCRIMINATOR:
        await handleRevenueClaimed(event.data);
        break;
      default:
        console.log('Unknown event:', event.name);
    }
  } catch (error) {
    console.error('Error processing event:', error);
  }
}

async function handleListingCreated(data: any) {
  try {
    console.log('Listing created:', {
      listingId: data.listingId.toString(),
      seller: data.seller.toString(),
      pricePerDay: data.pricePerDay.toString()
    });
    
    // Notify via WebSocket if needed
  } catch (error) {
    console.error('Error handling listing created event:', error);
  }
}

async function handleListingUpdated(data: any) {
  try {
    console.log('Listing updated:', {
      listingId: data.listingId.toString(),
      newEndDate: new Date(data.newEndDate.toNumber() * 1000),
      newPricePerDay: data.newPricePerDay.toString()
    });
  } catch (error) {
    console.error('Error handling listing updated event:', error);
  }
}

async function handleListingRemoved(data: any) {
  try {
    console.log('Listing removed:', {
      listingId: data.listingId.toString(),
      seller: data.seller.toString()
    });
  } catch (error) {
    console.error('Error handling listing removed event:', error);
  }
}

async function handleDataPassPurchased(data: any, merkleService: MerkleService) {
  try {
    console.log('Data pass purchased:', {
      passId: data.passId.toString(),
      buyer: data.buyer.toString(),
      totalPaid: data.totalPaid.toString(),
      eligibleSellerCount: data.eligibleSellerCount
    });

    // Trigger merkle distribution update for the current period
    const periodId = ScheduleService.getCurrentPeriodId();
    
    // Generate distribution (this would be done periodically, not on every purchase)
    // In production, you might batch these or do them on a schedule
    console.log(`Scheduling merkle update for period ${periodId} after pass purchase`);
    
  } catch (error) {
    console.error('Error handling data pass purchased event:', error);
  }
}

async function handleRevenueClaimed(data: any) {
  try {
    console.log('Revenue claimed:', {
      seller: data.seller.toString(),
      periodId: data.periodId.toString(),
      amount: data.amount.toString()
    });

    // Mark the proof as claimed in database
    await prisma.sellerProof.update({
      where: {
        seller_address_period_id: {
          seller_address: data.seller.toString(),
          period_id: BigInt(data.periodId.toString())
        }
      },
      data: {
        claimed: true,
        claimed_at: new Date()
      }
    });
  } catch (error) {
    console.error('Error handling revenue claimed event:', error);
  }
}